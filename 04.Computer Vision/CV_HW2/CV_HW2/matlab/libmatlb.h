/*
 * @(#)libmatlb.h    generated by: makeheader    Thu Mar 22 21:00:05 2001
 *
 *		built from:	include/copyright.h
 *				include/libmatlb_defs.h
 *				mlm/memory.c
 *				mlm/handler.c
 *				mlm/mlm.c
 *				mlm/varargs.c
 *				mlm/mlmdispatch.c
 *				mlm/index.c
 *				mlm/mlmscalar.c
 *				mlm/mlmsparse.c
 *				mlm/mxapi.c
 *				mlm/license.c
 *				mlm/feval.c
 *				mlm/meval.c
 *				mlm/mlmpath.c
 *				mlm/mclscalar.c
 *				mlm/validate.c
 *				mlm/mclmex.c
 *				mlm/mclinit.c
 *				mlm/forloop.c
 *				mlm/operators.c
 *				mlm/mlmpath.c
 *				mlm/mbfunctions.c
 *				mlm/wrappers.c
 *				mlm/overload.c
 *				mlm/mex_interface.c
 *				mlm/namehash.c
 *				include/libmatlb_post.h
 */

#ifndef libmatlb_h
#define libmatlb_h


/* $Revision: 1.1 $ */
/*
 * Copyright (c) 1984-1998 by The MathWorks, Inc.
 * All Rights Reserved.
 */


/*
 * $Revision: 1.3 $
 */

#ifndef libmatlb_defs_h
#define libmatlb_defs_h

#ifdef __cplusplus
    extern "C" {
#endif

#include <stddef.h>
#if defined(_H_STANDARDS) && !defined(__cplusplus)
#undef NULL

/*
 * The definition of NULL on IBM_RS, SGI and SGI64 causes problems.  
 * it is defined as 0L and it will not work in comma-lists:
 * (x,0L) is not compatible with a pointer type
 * Ultimately, we need to generate a different constant for error handling
 * so that this definition is no necessary here.
 * IBM_RS is detected by the H_STANDARDS header file that I believe only
 * exists there
 */

#define NULL ((void *) 0L)
#endif
   
#include "matrix.h"
#include "mwutil.h"

#if defined(MLF_V1_2) && defined(MLF_V2)
#undef MLF_V2
#endif

#if  !defined(MATLAB_COMPILER_GENERATED_CODE) && !defined(MLF_V1_2) && !defined(MLF_V2)
#define MLF_V2
#endif


#ifdef MLF_V2

#define MLF_ENABLE_ND_ARRAYS 1
#define MLF_USE_VARARGOUT 1

#ifndef __cplusplus
#define MLF_ENABLE_TRYCATCH 1
#endif /* __cplusplus */

#endif /* MLF_V2 */
        
/* macro proto: mxArray* mclCastToMxarray(void*) */
#define mclCastToMxarray(x) (mxArray *)(x)

#ifdef __cplusplus
    }	/* extern "C" */
#endif


#endif /* libmatlb_defs_h */

#ifdef __cplusplus
    extern "C" {
#endif


#include "matrix.h"

extern void* mclSafeMalloc(size_t sz);

extern void mclSafeFree(void *ptr);

extern void mlfSetLibraryAllocFcns( calloc_proc calloc_fcn, free_proc free_fcn,
                                    realloc_proc realloc_fcn, malloc_proc malloc_fcn);

extern void mclInitMemoryManager(void);


#include "matrix.h"
#include "mex.h"
#undef mexPrintf
typedef void (*ErrorHandlerFcn)(const char*, bool);

extern void libmmfile_defsInitialize(void);

extern void libmmfile_defsTerminate(void);

extern void libmatlbmxInitialize(void);

extern void libmatlbmxTerminate(void);

extern mxArray *mclGetUninitializedArray(void);


extern bool mclIsCommaList(mxArray *array);


extern bool mclIsNewContext(void);


extern void mclLibmmfileInitialize( void );

extern void mclDestroyArray(mxArray *a);

 
/* For use only by the compiler. Do not call this function */
extern bool mclIsTempArray(mxArray *a);

 
/* For use only by the compiler. Do not call this function */
extern void mclFixInternalMatrix(mxArray *a);

extern mxArray *mclCreateGlobal(void);

extern mxArray * mclCppOwnsArray(mxArray *pa);

extern void mclMoveArraysToCurrentContext(int count, mxArray **ppa);


/* This function is intended for use only by the MATLAB compiler. */
extern void mclAssignLastValue(mxArray **ans);

 
/* This function is intended for use only by the MATLAB compiler. */
extern mxArray *mclAssignAns(mxArray * volatile *dest, mxArray *src);


extern mxArray *mclPrintAns(mxArray * volatile *dest, mxArray *src);

extern mxArray *mlfAssign(mxArray * volatile *dest, mxArray *src);

extern void mlfClear(mxArray * volatile *var, ...);

extern mxArray *mclInitialize(mxArray *pa);

extern void mlfEnterNewContext(int nout, int nin, ...);

extern void mlfRestorePreviousContext(int nout, int nin, ...);

extern void mlfSetPrintHandler(void (* PH)(const char *));

extern ErrorHandlerFcn mlfSetErrorHandler(ErrorHandlerFcn EH);

extern void mclSetCppErrorHandler(ErrorHandlerFcn EH);

extern int mlfPrintf(const char* fmt, ...);

extern void mclInitLibrary( const char * path, int is_mcc );


extern void mclMexLibraryInit(void);

extern void mclLibmatlbInitialize(int argc, const char ** argv);

extern void mclLibmatlbTerminate(void);


extern void mclMemcheckInitLibrary( void );

extern void mlfInitFcn(void);

extern void mlfCleanupFcn(void);

extern void mlfCleanupOutputArray(mxArray* pa);


#include <setjmp.h>



typedef void (*mclExceptionFcn)(void*);

typedef struct mclErrorContext_tag
{
  int depth;
  int allocContext;
  int arrayContext;
  int libraryContext;
} mclErrorContext;

typedef struct mclTryCatchContext_tag
{
  mclErrorContext err_ctx;
  int err_mode;
  jmp_buf *buffer;
  ErrorHandlerFcn err_handler;
  mclExceptionFcn except_fcn;
  mclExceptionFcn trycatch_exception_fcn;
  mexLocalFunctionTable lft;
  struct mclTryCatchContext_tag *prev;
  /*
   * This structure must go last because of a mismatch in the size of
   * a jmp_buf between microsoft and borland compilers on the PC.
   * placing any fields after this is a guaranteed seg-fault!
   * The correct solution long-term is to use a different structure
   * in the error context for the ut_prevent_further_cleanup() function
   * which does not contain a jmp_buf.
   */
  _try_catch_list _link;
} mclTryCatchContext;
  

extern void mclNewErrorContext(mclErrorContext *errorCtx);

extern void mclRestoreErrorContext(mclErrorContext *errorCtx);



typedef struct mclCppContext_tag
{
    mclErrorContext errorCtx;
    ErrorHandlerFcn errorHandler;
} mclCppContext;


extern void mclEnterCppContext(mclCppContext *cppCtx);

extern void mclExitCppContext(mclCppContext *cppCtx);

extern void mclCppError(mclCppContext *cppCtx);

extern void mclMexError(void);

extern jmp_buf *mclGetSetjmpData(void);

extern void mclEnterTryCatchContext(mclTryCatchContext *ctx, jmp_buf *newbuf, mclExceptionFcn exception_fcn);

extern void mclExitTryCatchContext(mclTryCatchContext *ctx, int err_flag);


extern void mclCleanupProtectedItems( void );


extern void mclExitTryBlock(void);


#ifdef MLF_ENABLE_TRYCATCH 

static void _mclExceptionFcn(void* msg)
{
    mclExceptionFcn dummy;
    dummy = _mclExceptionFcn; msg = 0;/* Prevents compiler warning */
    mclCleanupProtectedItems();
    longjmp(*mclGetSetjmpData(), -1);
}

/*
 * Consider the following C source:
 *
 *   typedef long jb[5];
 *   ...
 *   jb b;
 *   jb *x = &b
 *
 * This causes the alpha compiler (and maybe others) to issue two warnings:
 *
 *   ... & before array "b" is ignored ...
 *
 *   ... the referenced type of the pointer value "&b" is "long",
 *       which is not compatible with "array [5] of long"
 *
 * Thus rather than &_mcl_tcbuf, which is what you might think is right,
 * the pointer needed in the second argument to mclEnterTryCatchContext is
 * obtained with a cast.
 */
#define mlfTry                                          \
{                                                       \
    jmp_buf _mcl_tcbuf;                                 \
    mclTryCatchContext _mcl_ctx;                        \
    mclEnterTryCatchContext(&_mcl_ctx,                  \
                            (jmp_buf *)_mcl_tcbuf,      \
                            _mclExceptionFcn);          \
    if (!setjmp(_mcl_tcbuf)) {

#define mclExitTryBlock_() mclExitTryCatchContext(&_mcl_ctx, 0)

#define mclCatchWithoutExit                     \
    } else {{                                   \
        mclExitTryCatchContext(&_mcl_ctx, 1);

#define mlfCatch  mclExitTryBlock_(); mclCatchWithoutExit

#define mlfEndCatch }}}

#endif



#define mlfLasterror mlfLasterr

extern bool mclIsOutOfMemoryError(void);

extern mxArray * mlfScalar(double v);


/* macro proto: mxArray* mclBoolToArray(bool b); */
#define mclBoolToArray(b) mlfScalar((double)b)

extern mxArray * mlfComplexScalar(double v, double i);

extern mxArray *mclComplexMatrixFromVector( int m, int n, double *pr, double *pi );


#define mclMatrixFromVector( m, n, pr ) mclComplexMatrixFromVector( m, n, pr, NULL )

extern mxArray * mlfDoubleMatrix(int m, int n, const double *pr, const double *pi);

extern double *mlfGetPr(mxArray *pa);

extern void mlfSetPr(mxArray *pa, double *pr);

extern double *mlfGetPi(mxArray *pa);

extern void mlfSetPi(mxArray *pa, double *pi);

extern bool mclSwitchCompare(mxArray *switchvar, mxArray *casevar);

extern mxArray * mclCreateEmptyArray(void );


/* macro proto: int mclArrayToInt(mxArray* arg); */
#define mclArrayToInt(x) ((int)(*mxGetPr(x)))

extern mxArray * mclCreateCellFromStrings(int count, const char** strings);

extern mxArray * mclCreateEmptyCell(void);

extern bool mlfTobool(mxArray *pa);

extern void mlfAddFlops(double f);

extern void mlfSetLibraryCalloc(void *func);

extern void mlfSetLibraryMalloc(void *func);

extern void mlfSetLibraryFree(void *func);

extern void mlfPrintMatrix(mxArray *RI1);

extern void mclPrintArray(mxArray *RI1, const char *name);

extern void mlxColon(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);

extern mxArray * mlfColon(mxArray *in1, mxArray *in2, mxArray *in3);

extern void mlfSave(mxArray *file, const char* mode, ... );

extern void mlfSave_v12(const char* file, const char* mode, ...);

extern void mlfLoad(mxArray *file, ... );

extern void mclLoadConditional(mxArray *file, ... );

extern void mlfLoad_v12(const char* file, ...);

extern mxArray *mclCreateStructFromMatFile(mxArray *matfile, int numfields, mxArray **names);

extern mxArray *mlfLoadStruct(mxArray *matfile, mxArray* pa, ...);


#ifndef MLF_ENABLE_ND_ARRAYS
#define mlfSave mlfSave_v12
#define mlfLoad mlfLoad_v12
#endif

extern mxArray * mlfRand(mxArray *in1, ...);

extern mxArray * mlfNRand(int nargout, mxArray *in1, ...);

extern mxArray * mlfRandn(mxArray *in1, ...);

extern mxArray * mlfNRandn(int nargout, mxArray *in1, ...);

extern void mlxRand(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);

extern void mlxRandn(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);


extern void mclVoid(mxArray *pa);

extern double mclGetInf(void);


/* macro proto: double mclGetMinusInf(void); */
#define mclGetMinusInf() (-mclGetInf())
#include <limits.h> /* defines INT_MIN */
/* macro proto: int mclIntMin(void); */
#define mclIntMin() INT_MIN

extern double mclGetNaN(void);


#include <stdarg.h>
#include "matrix.h"      /* Flopper and function_object types, other functions */

#define MLFMAXVAR 100

#define mlfVararginDecls                                \
    int nrhs = 0, size = MLFMAXVAR;                     \
    mxArray *prhslocal[MLFMAXVAR], **prhs = prhslocal;  \
    mxArray *patemp;

#define mlfVararginBody(varargin, last, uselast, ap)                    \
    if (uselast) {                                                      \
        patemp = last;                                                  \
    } else {                                                            \
        patemp = va_arg(ap, mxArray *);                                 \
    }                                                                   \
    while(patemp != NULL) {                                             \
        prhs[nrhs++] = patemp;                                          \
        if (nrhs == size) {                                             \
            size = mclExpandVararginList(&prhs, size, prhslocal);       \
        }                                                               \
        patemp = va_arg(ap, mxArray *);                                 \
    }                                                                   \
    mlfAssign(varargin, mclUnpackVararginToCell(nrhs, prhs));           \
    if (prhs != prhslocal) mxFree(prhs);

/* mlfVarargin assigns, via the varargin argument, a cell array which is temporary and
 * is in the caller's array list context.  Any temporary inputs to the varargs function
 * will be owned by the cell array.  The cell array will have a reference count of 1,
 * and must be explicitly destroyed.  */

/* Can't pass a va_list to a library compiled with a non-default compiler.  */
#if (defined(__WATCOMC__) || defined(__BORLANDC__) || (defined(__GNUC__) && !defined(__linux__)))
#define mlfVarargin( varargin, last, uselast)                   \
{                                                               \
    mlfVararginDecls                                            \
    va_list ap;                                                 \
    va_start(ap, last);                                         \
    mlfVararginBody(varargin, (mxArray*)last, uselast, ap)      \
    va_end(ap);                                                 \
}
#else
#define mlfVarargin( varargin, last, uselast)                   \
{                                                               \
    va_list ap;                                                 \
    va_start(ap, last);                                         \
    mclVarargin(varargin, (mxArray*)(void*)last, uselast, ap);  \
    va_end(ap);                                                 \
}
#endif

 
/* For math library use only.  Do not call this function.*/
extern int mclExpandVararginList(mxArray ***prhs, int size, mxArray **prhslocal);

extern int mclUnpackCommaList(mxArray **prhs, mxArray *m, bool to_cell, bool is_cpp_array);

 
/* For math library use only.  Do not call this function.*/
extern mxArray *mclUnpackVararginToCell(int nrhs, mxArray **prhs);


extern void mclVarargin(mxArray ** varargin, mxArray * last, int uselast, va_list ap);


extern int mlfCountVarargin(va_list ap, mxArray *first);


/* For math library use only.  Do not call this function.*/
extern void mlfUnpackVarargin(va_list ap, mxArray **prhs, mxArray *first);

extern mxArray *mlfCellhcat(mxArray *pa, ...);

extern void mlxCellhcat(int nlhs, mxArray **plhs, int nrhs, mxArray **prhs);

extern int mclNargin(int nargs, ...);


typedef struct mlfVarargoutList_tag mlfVarargoutList;

extern int mclNargout(mlfVarargoutList *varargout);

extern mlfVarargoutList *mlfIndexVarargout(mxArray **ppa, ...);

extern mlfVarargoutList *mlfVarargout(mxArray **ppa, ...);

extern mxArray *mlfGetVarargoutCell(mlfVarargoutList *v);

extern mxArray **mlfGetVarargoutCellPtr(mlfVarargoutList *v);

extern mlfVarargoutList *mclAnsVarargout(void);

extern mlfVarargoutList *mclNVarargout(int nargout, int varargout_used, ...);

extern mlfVarargoutList *mclValueVarargout(void);

extern mxArray *mlfAssignOutputs(mlfVarargoutList *v);

extern void mclCreateVarargoutCell(mlfVarargoutList *vout, int nvarargs, mxArray **ppa);


extern void mclAssignVarargoutCell(int offset, int nlhs, mxArray *plhs[], mxArray *cell);


extern mxArray *mclCreateVararginCell(int nrhs, mxArray *prhs[]);


typedef void (*mlfFcnPtr)(int, mxArray**, int, mxArray**);



typedef struct mlfDispatchTable_tag 
{
  mlfFcnPtr *vtab;
  const char** funcnames;
  int nfuncs;
} mlfDispatchTable;



#define MLF_DEFAULT_INDEX_SIZE 4

typedef unsigned char mlfIndexType;
struct mlfIndexDef_tag
{
    int num_index_ops;
    mlfIndexType *type;
    int *idx;
    mxArray **subscripts;
    int  *fieldptrs;
    char *fieldnames;
    mlfIndexType type_local[MLF_DEFAULT_INDEX_SIZE];
    int idx_local[MLF_DEFAULT_INDEX_SIZE+1];
    mxArray *subscripts_local[MLF_DEFAULT_INDEX_SIZE];
    int fieldptrs_local[MLF_DEFAULT_INDEX_SIZE+1];
    char fieldnames_local[MLF_DEFAULT_INDEX_SIZE];
    mxArray **dest;
    int size;
    int max_size;
    mxArray *lastref;
};
#define mlfCELL 0
#define mlfARRAY 1
#define mlfSTRUCT 2
typedef struct mlfIndexDef_tag mlfIndexDef;


/* For use only by the C++ math library. Do not call this function. */
extern void mclInitIndex(mlfIndexDef *index_def);

extern void mclDestroyIndexDef(mlfIndexDef *index_def, int free_flag);

extern void mclCopyIndexDef(mlfIndexDef *dest, const mlfIndexDef *src);


/* For use only by the C++ math library. Do not call this function. */
extern void mclAddIndex(mlfIndexDef *index_def, mlfIndexType type, int nsubscripts, mxArray **psubscripts);


extern void mclAddFieldToLastIndex(mlfIndexDef *index_def, const char* fname_in);


/* For use only by the C++ math library. Do not call this function. */
extern mxArray *mclComplexRef(mxArray *pa, mlfIndexDef *index_def);

 
/* This function is intended for use only by the C++ math library */
extern void mclComplexAssign(mlfIndexDef *index_def, mxArray *src, bool packCell, bool do_scalar_assign);

extern void mclPrintIndex(const char* index_string, ...);

extern mxArray * mlfIndexRef(mxArray *pa, const char* index_string, ...);

extern mxArray * mlfIndexAssign(mxArray * volatile *pa, const char* index, ...);

extern mxArray * mlfIndexDelete(mxArray * volatile *pa, const char* index, ...);

extern mxArray* mlfArrayRef(mxArray *array, ...);

extern void mlfArrayAssign(mxArray *dest, mxArray *src, ...);

extern void mlfArrayDelete(mxArray *dest, ...);

extern mxArray * mlfCreateColonIndex( void );

extern bool mlfIsColonIndex(mxArray *a);


extern int mclGetNumberOfIndexedElements(mlfIndexDef *index_def);


/* For use only by the C++ math library */
extern int mclMultiAssign(mlfIndexDef *index_def, mxArray **prhs, int max_rhs_size);


extern mxArray *mclArrayRef1( mxArray *pa, mxArray *sub );


extern mxArray *mclArrayRef2( mxArray *pa, mxArray *sub1, mxArray *sub2 );


extern mxArray *mclIntArrayRef1( mxArray *pa, int sub );


extern mxArray *mclIntArrayRef2( mxArray *pa, int sub1, int sub2 );


extern void mclArrayAssign1( mxArray **dest, mxArray *src, mxArray *sub );


extern void mclArrayAssign2( mxArray **dest, mxArray *src, mxArray *sub1,  mxArray *sub2 );


extern void mclIntArrayAssign1( mxArray **dest, mxArray *src, int sub );


extern void mclIntArrayAssign2( mxArray **dest, mxArray *src, int sub1, int sub2 );

extern void *mclMalloc(size_t s);

extern void *mclCalloc(size_t c, size_t s);

extern void *mclRealloc(void *p, size_t s);



#ifdef mxMalloc
#undef mxMalloc
#endif
#define mxMalloc mclMalloc

#ifdef mxCalloc
#undef mxCalloc
#endif
#define mxCalloc mclCalloc

#ifdef mxRealloc
#undef mxRealloc
#endif
#define mxRealloc mclRealloc


extern int mclUnshareArray(mxArray *pa, int level);


#ifdef mxUnshareArray
#undef mxUnshareArray
#endif
#define mxUnshareArray mclUnshareArray

extern mxArray *mclCreateCellArray(int ndim, const int *dims);


#ifdef mxCreateCellArray
#undef mxCreateCellArray
#endif
#define mxCreateCellArray mclCreateCellArray

extern mxArray *mclCreateCharMatrixFromStrings(int m, const char **str);


#ifdef mxCreateCharMatrixFromStrings
#undef mxCreateCharMatrixFromStrings
#endif
#define mxCreateCharMatrixFromStrings mclCreateCharMatrixFromStrings

extern mxArray *mclCreateDoubleMatrix(int m, int n, mxComplexity ComplexFlag);


#ifdef mxCreateDoubleMatrix
#undef mxCreateDoubleMatrix
#endif
#define mxCreateDoubleMatrix mclCreateDoubleMatrix

extern mxArray *mclCreateNumericArray(int ndim, const int *dims, 
                                      mxClassID clsid, mxComplexity ComplexFlag);


#ifdef mxCreateNumericArray
#undef mxCreateNumericArray
#endif
#define mxCreateNumericArray mclCreateNumericArray

extern mxArray *mclCreateSparse(int m, int n, int nzmax, 
                                mxComplexity ComplexFlag);


#ifdef mxCreateSparse
#undef mxCreateSparse
#endif
#define mxCreateSparse mclCreateSparse

extern mxArray *mclCreateString(const char *str);


/* macro proto: mxArray* mxCreateString(char* arg); */
#ifdef mxCreateString
#undef mxCreateString
#endif
#define mxCreateString mclCreateString

extern mxArray *mclCreateStructArray(int ndim, const int *dims, int nfields,
                                    const char **field_names);


#ifdef mxCreateStructArray
#undef mxCreateStructArray
#endif
#define mxCreateStructArray mclCreateStructArray

extern mxArray *mclCreateStructMatrix(int m, int n, int nfields, 
                                      const char **field_names);


#ifdef mxCreateStructMatrix
#undef mxCreateStructMatrix
#endif
#define mxCreateStructMatrix mclCreateStructMatrix

extern mxArray *mclDuplicateArray(const mxArray *in);


#ifdef mxDuplicateArray
#undef mxDuplicateArray
#endif
#define mxDuplicateArray mclDuplicateArray

extern mxArray *mclGetCell(const mxArray *array_ptr, int index);


#ifdef mxGetCell
#undef mxGetCell
#endif
#define mxGetCell mclGetCell

extern void *mclGetData(const mxArray *array_ptr);


#ifdef mxGetData
#undef mxGetData
#endif
#define mxGetData mclGetData

extern mxArray *mclGetField(const mxArray *array_ptr, int index, 
                            const char *field_name);


#ifdef mxGetField
#undef mxGetField
#endif
#define mxGetField mclGetField

extern mxArray *mclGetFieldByNumber(const mxArray *array_ptr, int index, 
                                   int field_number);


#ifdef mxGetFieldByNumber
#undef mxGetFieldByNumber
#endif
#define mxGetFieldByNumber mclGetFieldByNumber

extern void *mclGetImagData(const mxArray *array_ptr);


#ifdef mxGetImagData
#undef mxGetImagData
#endif
#define mxGetImagData mclGetImagData

extern int *mclGetIr(const mxArray *array_ptr);


#ifdef mxGetIr
#undef mxGetIr
#endif
#define mxGetIr mclGetIr

extern int *mclGetJc(const mxArray *array_ptr);


#ifdef mxGetJc
#undef mxGetJc
#endif
#define mxGetJc mclGetJc

extern double *mclGetPr(const mxArray *array_ptr);


#ifdef mxGetPr
#undef mxGetPr
#endif
#define mxGetPr mclGetPr

extern double *mclGetPi(const mxArray *array_ptr);


#ifdef mxGetPi
#undef mxGetPi
#endif
#define mxGetPi mclGetPi

extern void mclSetCell(mxArray *array_ptr, int index, mxArray *value);


#ifdef mxSetCell
#undef mxSetCell
#endif
#define mxSetCell mclSetCell

extern void mclSetData(mxArray *array_ptr, void *data_ptr);


#ifdef mxSetData
#undef mxSetData
#endif
#define mxSetData mclSetData

extern int mclSetDimensions(mxArray *array_ptr, const int *dims, int ndims);


#ifdef mxSetDimensions
#undef mxSetDimensions
#endif
#define mxSetDimensions mclSetDimensions

extern void mclSetField(mxArray *array_ptr, int index, 
                        const char *field_name, mxArray *value);


#ifdef mxSetField
#undef mxSetField
#endif
#define mxSetField mclSetField

extern void mclSetFieldByNumber(mxArray *array_ptr, int index, 
                               int field_number, mxArray *value);


#ifdef mxSetFieldByNumber
#undef mxSetFieldByNumber
#endif
#define mxSetFieldByNumber mclSetFieldByNumber

extern void mclSetImagData(mxArray *array_ptr, void *pi);


#ifdef mxSetImagData
#undef mxSetImagData
#endif
#define mxSetImagData mclSetImagData

extern void mclSetIr(mxArray *array_ptr, int *ir);


#ifdef mxSetIr
#undef mxSetIr
#endif
#define mxSetIr mclSetIr

extern void mclSetJc(mxArray *array_ptr, int *jc);


#ifdef mxSetJc
#undef mxSetJc
#endif
#define mxSetJc mclSetJc

extern void mclSetPi(mxArray *array_ptr, double *pi);


#ifdef mxSetPi
#undef mxSetPi
#endif
#define mxSetPi mclSetPi

extern void mclSetPr(mxArray *array_ptr, double *pr);


#ifdef mxSetPr
#undef mxSetPr
#endif
#define mxSetPr mclSetPr

extern mxArray *mclCreateSharedCopy(const mxArray *pa);


#ifdef mxCreateSharedCopy
#undef mxCreateSharedCopy
#endif
#define mxCreateSharedCopy mclCreateSharedCopy


#include "mex.h"
#undef printf

typedef void (*mlfFuncp)( void );

typedef int (*mlfThunkp)( mlfFuncp pFunc, int nlhs, mxArray **plhs, int nrhs, mxArray **prhs );

typedef struct {
    char *name;
    mlfFuncp pFunc;
    mlfThunkp pThunk;
} mlfFuncTabEnt;

typedef mlfFuncTabEnt mlfFuncTab;  /* Table is just an array of entries */


extern mexLocalFunctionTable mclSetCurrentLocalFunctionTable(mexLocalFunctionTable lft);


extern mxFunctionPtr 
mclFevalLookup( mxArray* fcn );


extern mxFunctionPtr 
mlfFevalLookup(mxArray *fcn);


/*
 *  General call to another mexfile for feval.
 *  This function is identical to mlfCallMATLAB except
 *  for the "real work" section where it calls
 *  another mex file instead of mexCallMATLAB.
 */
extern void
mlfFeval_12( int nlhs, mxArray **plhs, int nrhs, mxArray **prhs, const char *name );


extern void mlfFevalTableSetup( mlfFuncTab *mlfUfuncTable );

 
extern void mlfFunctionTableSetup(size_t size, mexFunctionTable pTab);

 
extern void mlfFunctionTableTakedown(size_t size, mexFunctionTable pTab);


/*
 * Used by C++ math library.
 */
extern void mclFevalArray( int nlhs, mxArray **plhs, int nrhs, mxArray **prhs );

 
extern mxArray * mclFeval(mlfVarargoutList *varargout, mxFunctionPtr mxfn, ...);

 
extern mxArray * mlfFeval(mlfVarargoutList *varargout, ...);


extern void mlxFeval( int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[] );

 
extern mxArray * mlfBuiltin(mlfVarargoutList *varargout, ...);


extern void mlxBuiltin( int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]);


extern mxArray * mclCreateSimpleFunctionHandle(mxFunctionPtr f, const char *name);

 
extern void mcl_eval_string_fcn( int nlhs, mxArray **plhs, const char *str, 
                          mxFunctionPtr (*lookup)(char* name, void *lookup_x), void *lookup_x );


extern void
mclEvalString(  int nlhs, mxArray **plhs, const char *str );


extern void mclAddPaths( size_t num_paths, const char **paths );


extern bool mclFindFirstFileName(
    const char	*name,
    bool	supply_matlab_exts,
    char	*fullname
    );


extern void mclInitMatlabRoot( int *argc, const char **argv );


extern double mclDivideDouble(double x, double y);


extern double mclLeftDivideDouble(double x, double y);


extern mxArray *mclDivideDoublePair(double x1, double x2, double y1, double y2);


extern mxArray *mclLeftDivideDoublePair(double x1, double x2, double y1, double y2);


extern int mclLengthInt(mxArray *a);


/* macro proto: mxArray* mclInitializeAns(); */
#define mclInitializeAns() mclGetUninitializedArray()
#define mclInitializeNull() mclGetUninitializedArray()
#define mclIsUninitialized(pa) (mxGetClassID(pa) == mxUNKNOWN_CLASS)
#define mclIsInitialized(pa) (pa != NULL && !mclIsUninitialized(pa))

extern mxArray *mlfReturnValue(mxArray *a);

 
extern bool mclUninitWarning( const char *vname );


typedef enum mclValidateErrorCode {
  mclINPUT_UNDEFINED=0,
  mclFCN_OR_VARIABLE_UNDEFINED
} mclValidateErrorCode;


#ifndef WARNING_FREE_CODE

#define mclIsUninitializedWarn( in, vname ) ( mclIsUninitialized(in) ? mclUninitWarning(vname) : false )

/*
 * If "in" is Undefined, throw an error.
 * If "in" is Uninitialized, return [].  Otherwise return "in".
 */

#define mclVva_uninitialized( in, vname)                                \
   !mclIsUninitializedWarn(in,vname) ? in : mclCreateEmptyArray()

#define mclVs_uninitialized( in, vname) (mclIsUninitializedWarn(in,vname), in)


#define mclVve( in, vname )                                            \
( mclIsUninitializedWarn( in, vname ) ? mclCreateEmptyArray() : in )

#else

#define mclVva_uninitialized( in, vname) in
#define mclVs_uninitialized( in, vname) in
#define mclVve( in, vname ) in

#endif

/* macro proto: mxArray* mclVa(mxArray* in, char* vname); */
/* macro proto: mxArray* mclVv(mxArray* in, char* vname); */
/* macro proto: void mclVo(mxArray** in); */
/* macro proto: mxArray* mclVsa(mxArray* in, char* vname); */
/* macro proto: mxArray* mclVsv(mxArray* in, char* vname); */
/* macro proto: mxArray* mclVg(mxArray* in, char* vname); */

#define mclVva( in, errcode, vname )                                                    \
( in != NULL ? mclVva_uninitialized(in, vname) : mclValidateError( errcode, vname ) )

#define mclVs_(in, errcode, vname )                                                     \
( (in) != NULL ?  mclVs_uninitialized(in, vname) : mclValidateError(errcode, vname ) )

#define mclVa(in, vname) mclVva(in, mclINPUT_UNDEFINED, vname)

#define mclVv(in, vname) mclVva(in, mclFCN_OR_VARIABLE_UNDEFINED, vname)

#define mclVsv(in, vname) mclVs_(in, mclFCN_OR_VARIABLE_UNDEFINED, vname)

#define mclVsa(in, vname) mclVs_(in, mclINPUT_UNDEFINED, vname)

#define mclVo( output ) { if ( *output == NULL ) *output = mclGetUninitializedArray(); }


 
extern mxArray *mclValidateError( mclValidateErrorCode code, const char *vname );


extern mxArray *mclVe( mxArray *in );


#ifdef WARNING_FREE_CODE
#define mclVe(in) in
#endif


extern void mclCopyInputArg( mxArray * volatile *dest, mxArray *src );

 
extern void mclCopyArray( mxArray **pa );


extern void mclCopyOutputArg(mxArray * volatile *dest, mxArray *src);


extern void mclValidateOutputWarning( const char *vname, const char *fname );



/* macro proto: void mclValidateOutput(mxArray*, int, int, char*, char*); */

#ifndef WARNING_FREE_CODE
#define mclValidateOutput( output, pos, nargout, vname, fname ) \
{                                                               \
  if ((output) == NULL) {                                       \
     mlfAssign( &(output),  mclGetUninitializedArray() );       \
  }                                                             \
  else                                                          \
  if ( pos <= nargout && mclIsUninitialized(output) ) {         \
    mclValidateOutputWarning( vname, fname );                   \
  }                                                             \
} (void)0
#else
#define mclValidateOutput( output, pos, nargout, vname, fname ) \
{                                                               \
  if ((output) == NULL)                                         \
     mlfAssign( &(output),  mclGetUninitializedArray() );       \
} (void)0
#endif


extern mxArray ** mclInitGlobal( mxArray **g );


/* macro proto: mxArray** mclPrepareGlobal(mxArray** g); */
#define mclPrepareGlobal(g) ((*g != NULL) ? g : mclInitGlobal(g))


extern mxArray *mclVg( mxArray **pg, const char *name );


/* Common definitions */
#define mclAppendMlineCommon()                                  \
      mclAppendMlineToError( (const char *) __M_file_name,      \
                             (const char *) __M_function_name,  \
                             (size_t) __M_line_number );

#define mclMlineEnterFunctionCommon(file_name, function_name )  \
{ const char * volatile __M_file_name = file_name;              \
  const char * volatile __M_function_name = function_name;      \
  volatile size_t __M_line_number = 0; 

#ifdef __cplusplus
#ifdef EXCEPTIONS_WORK

#define mclMlineEnterFunction( file_name, function_name )       \
  mclMlineEnterFunctionCommon( file_name, function_name)        \
   try{

#define mclMlineExitFunction()                  \
  } catch (mwException &) {                     \
      mclAppendMlineCommon()                    \
      error( lasterror() );                     \
  } } return

#else /* if !EXCEPTIONS_WORK */

#define mclMlineEnterFunction mclMlineEnterFunctionCommon

#define mclMlineExitFunction() } return

#endif /* EXCEPTIONS_WORK */

#define mclMlineFunctionReturn()  
#define mclMlineExitFunctionReturn() mclMlineExitFunction() mwArray()

#else /* if !__cplusplus */

#define mclMlineEnterFunction( file_name, function_name )       \
  mclMlineEnterFunctionCommon( file_name, function_name )       \
  mlfTry {

#define mclMlineExitFunctionCommon()             \
      mclAppendMlineCommon()                    \
      mlfError( mlfLasterror(NULL) );           \
  } mlfEndCatch } return

#define mclMlineExitFunction()                  \
  } mlfCatch {                                  \
  mclMlineExitFunctionCommon()

#define mclMlineFunctionReturn()  mclExitTryBlock_();
#define mclMlineExitFunctionReturn()                            \
   } mclCatchWithoutExit { mclMlineExitFunctionCommon() NULL

#endif /* !__cplusplus */

#define mclMline( line ) __M_line_number = line;



extern void mclAppendMlineToError(const char *file_name, const char *function_name, size_t line_number );


typedef void (*fn_mcl_assign_global)( void *X, mxArray *new_value );


typedef mxArray *(*fn_mcl_get_global)( void *X );


extern void mclSetMexGlobalCallbacks( fn_mcl_assign_global assign_global,
                               fn_mcl_get_global get_global );


extern void mclInsertGlobal( void *g, const char *gname );


extern void mclMexInitGlobals( mex_information info );


extern mxArray * mclExecMexFile( mlfVarargoutList *varargout,
                          const char *name, ...);


extern mxArray * mclCExecMexFunction(const char * fcn_name, int nargout_, mxArray * varargin);


extern mxArray *mclInitializeDouble( double d );


extern mxArray *mclInitializeComplex( double re, double im );


extern mxArray *mclInitializeComplexVector( int m, int n, double *pr, double *pi );


extern mxArray *mclInitializeDoubleVector( int m, int n, double *pr );


extern mxArray *mclInitializeString( int len, mxChar *string_pr );


extern mxArray *mclInitializeCharVector( int m, int n, mxChar *string_pr );


extern mxArray *mclInitializeCell( mxArray *cell );

 
extern mxArray *mclInitializeCellVector( int m, int n, mxArray **cell_pr );


extern mxArray *mclInitializeOther( unsigned char *buf, size_t size );


extern void mclInitializePersistent(mxArray* volatile * pv);


extern mxArray *mclInitializeLogical( bool b );


extern mxArray *mclInitializeLogicalVector( int m, int n, double *pr );


typedef enum {mclFOR_COLON, mclFOR_NUMERIC, mclFOR_GENERIC} mclForLoopCategory;

typedef struct _mclForLoopIterator mclForLoopIterator;

typedef void (*fn_for_next)( mclForLoopIterator *iter, mxArray * index );

/* For use only by the Matlab compiler. */
struct _mclForLoopIterator {
  int curridx;  /* Current index into loop array */
  int maxidx;   /* number of times to repeat the loop */
  mclForLoopCategory category;
  fn_for_next start;
  fn_for_next next;
  union {
    struct {
      int m;
      unsigned char scalar;
      unsigned char logical;
      void *pr;
      void *pi;
      int nel;
      mxArray *loop_array;  /* array over which we are iterating, (null if colon index) */
    } num;
    struct {
      double start; /* start value (ignored if not colon) */ 
      double delta; /* step value (ignored if not colon) */ 
    } colon;
    struct {
      mxArray *loop_array;  /* array over which we are iterating, (null if colon index) */
      mxArray *row; /* row index (null if colon index) */ 
      mxArray *col; /* column index (null if colon index)*/
    } arr;
  } iter;
};

#define mclForDone 0

 
/* For use only by the Matlab compiler.  Do not call this function. */
extern void mclDestroyForLoopIterator_(mclForLoopIterator *iter);


/* macro proto: void mclDestroyForLoopIterator(mclForLoopIterator *iter) */
#define mclDestroyForLoopIterator(x) mclDestroyForLoopIterator_(&x)

 
/* For use only by the Matlab compiler.  Do not call this function. */
extern void mclForStart(mclForLoopIterator *iter, mxArray *pa, mxArray *pa2, mxArray *pa3);


typedef mxArray * volatile *mclVolatileArrayPtr;

 
/* For use only by the Matlab compiler.  Do not call this function. */
extern int mclForNext(mclForLoopIterator *iter, mclVolatileArrayPtr ppa);


/* For use only by the Matlab compiler.  Do not call this function. */
/*
 * The purpose of this function is to ensure that a value of INT_MIN for
 * the upper bound of a loop always causes a null loop.  This is true as
 * long as the start of the loop is not exactly INT_MIN.
 */
extern int mclForIntStart(int s);


/* For use only by the Matlab compiler.  Do not call this function. */
/*
 * The next two functions are based on mxColonop_size for integer values of
 * what are there called a and d.
 */
extern int mclForIntEnd(mxArray *e); /* The increment is implicitly 1 */


/* For use only by the Matlab compiler.  Do not call this function. */
/*
 * When comparing to mxColonop_size, s corresponds to a, and i to d.
 * This returns the exact endpoint, so termination can be done by equality,
 * independently of the sign of i.
 */
extern int mclForIntIntEnd(int s, int i, mxArray *e);


extern mxArray *mclPlus( mxArray *a, mxArray *b );


extern mxArray *mclMinus( mxArray *a, mxArray *b );


extern mxArray *mclTimes( mxArray *a, mxArray *b );


extern mxArray *mclMtimes( mxArray *a, mxArray *b );


extern mxArray *mclRdivide( mxArray *a, mxArray *b );


extern mxArray *mclMrdivide( mxArray *a, mxArray *b );


extern mxArray *mclMpower( mxArray *a, mxArray *b );


extern mxArray *mclEq( mxArray *a, mxArray *b );


extern mxArray *mclNe( mxArray *a, mxArray *b );


extern mxArray *mclLt( mxArray *a, mxArray *b );


extern mxArray *mclGt( mxArray *a, mxArray *b );


extern mxArray *mclLe( mxArray *a, mxArray *b );


extern mxArray *mclGe( mxArray *a, mxArray *b );


extern mxArray *mclAnd( mxArray *a, mxArray *b );


extern mxArray *mclOr( mxArray *a, mxArray *b );


extern mxArray *mclUplus( mxArray *a );


extern mxArray *mclUminus( mxArray *a );


extern mxArray *mclNot( mxArray *a );


extern bool mclEqBool( mxArray *a, mxArray *b );


extern bool mclNeBool( mxArray *a, mxArray *b );


extern bool mclLtBool( mxArray *a, mxArray *b );


extern bool mclGtBool( mxArray *a, mxArray *b );


extern bool mclLeBool( mxArray *a, mxArray *b );


extern bool mclGeBool( mxArray *a, mxArray *b );


extern bool mclNotBool( mxArray *a );


extern void mclAddPaths( size_t num_paths, const char **paths );


extern bool mclFindFirstFileName(
    const char	*name,
    bool	supply_matlab_exts,
    char	*fullname
    );


extern void mclInitMatlabRoot( int *argc, const char **argv );


extern void mclLibInitGlobals(int length, mexGlobalTable globals);


extern void mclLibTermGlobals(int length, mexGlobalTable globals);


extern void mclLibInitInitTerms(int length, mexInitTermTableEntry inits);


extern void mclLibTermInitTerms(int length, mexInitTermTableEntry terms);


extern void mclLibInitCommon( mex_information info );


extern void mclLibInit(int * ref, mex_information info);


extern void mclLibTermCommon( mex_information info );


extern void mclLibTerm(int * ref, mex_information info);


extern int mclMain( int argc, const char **argv, mxFunctionPtr mlxfn, bool nout, mex_information info );


extern mex_information mclMex( mex_information mex_info );


extern void mclMextest( int nlhs, mxArray **plhs, int nrhs, const mxArray **prhs, mxFunctionPtr mlxF, mex_information info, const char *mfcn );


/*
 * These macros are for backward compatibility.
 */
#define mclGlobalTableEntry mexGlobalTableEntry
#define mclExportGlobal mexExportGlobal
#define mlfFunctionTableEntry mexFunctionTableEntry


extern mxArray * mclFevalCallMATLAB(mlfVarargoutList *varargout,
                               const char *name, ...);


extern int mclSupportedDataTypes(int nrhs, const mxArray **prhs);


/*
 * $Revision: 1.1 $
 */

#include "libmatlbm.h"
#include "libsgl.h"

#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* libmatlb_h */
